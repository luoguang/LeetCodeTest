package com.luog;

/**
 * 字典序算法用来解决这样一个问题：给定其中一种排列，求基于字典序的下一种排列。
 * <p>
 * 比如给定一种排列为 abc，则其基于字典序的下一种排列为 acb。
 * <p>
 * 要求下一种排列既要比原排列大，又不能有第三种排列位于他俩之间。即下一种排列为大于原排列的最小排列。
 * <p>
 * 以输入为 358764 为例，字典序算法的步骤：
 * 1、从原排列中，从右至左，找到第一个左邻小于右邻的字符，记左邻位置为 a。
 * 示例中 a=1，list[a] = 5。
 * 2、重新从右至左，找到第一个比 list[a] 大的字符，记为位置为 b。
 * 示例中 b=4，list[b] = 6。
 * 3、交换 a 和 b 两个位置的值。
 * 示例变为了 368754。
 * 4、将 a 后面的数，由小到大排列。
 * 示例变为了 364578。
 * <p>
 * 算法结束，输出 364578。
 * <p>
 * 注意：
 * 1、第1步中，如果找不到左邻小于右邻的数，则说明给定的排列已经是全排列的最后一个排列了，则直接返回全排列的第一个排列，即所有排列中最小的排列，形成一个循环。
 * 2、在第3步交换前，a 后面的数是按照从大到小进行排列（否则第1步中就可以找到左邻小于右邻的数了）。
 * 3、在交换之后，a 后面的数仍然是按照从大到小排列的，尽管 b 位置的值变成了 list[a]，但是由于 b 位置是第一个比 list[a] 大的，因此交换之后 list[a] 仍然比左邻小，比右邻大。
 * 4、既然 a 后面的数是从大到小排列的，那么第4步的排序，直接将 a 后面的数倒序即可。
 * <p>
 * 算法的时间复杂度为 O(n) + O(n) + O(n) = O(n)。
 * ————————————————
 * 版权声明：本文为CSDN博主「HappyRocking」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
 * 原文链接：https://blog.csdn.net/happyrocking/article/details/83619392
 */
public class Solution1 {
    /**
     * @param nums
     */
    public void nextPermutation(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }

        int len = nums.length;
        int k = len - 1;

        // 找到从右到左第一个降序值（k-1，k表示最后一个升序值）
        while (k > 0 && nums[k - 1] >= nums[k]) {
            k--;
        }

        int tmp = 0;
        // 从右往左，找到比第一个降序值大的第一个值，并与降序值交换
        if (k > 0) {
            int i = len - 1;
            while (i > k - 1 && nums[i] <= nums[k - 1]) {
                i--;
            }

            tmp = nums[i];
            nums[i] = nums[k - 1];
            nums[k - 1] = tmp;
        }

        // 反转第一个降序值以后的值；若元数组是降序的，则k=0，反转整个数组
        for (int j = 0; j <= (len - k - 1) / 2; j++) {
            tmp = nums[k + j];
            nums[k + j] = nums[len - 1 - j];
            nums[len - 1 - j] = tmp;
        }
    }
}
